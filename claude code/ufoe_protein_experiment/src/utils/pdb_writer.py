"""
PDB 파일 작성 유틸리티

Cα 좌표와 서열로부터 PDB 형식 파일을 생성한다.
Phase 2에서 MD 시뮬레이션 입력 및 결과 저장에 사용.
"""

from __future__ import annotations

from pathlib import Path

import numpy as np

from src.utils.constants import AA_3TO1, AA_1TO3, PDB_CHAIN_DEFAULT
from src.utils.pdb_parser import ProteinStructure


def write_pdb_from_coords(
    filepath: str | Path,
    ca_coords: np.ndarray,
    residue_names: list[str],
    chain_id: str = PDB_CHAIN_DEFAULT,
    pdb_id: str = "UFOE",
    b_factors: np.ndarray | None = None,
) -> Path:
    """Cα 좌표와 잔기 이름으로 PDB 파일을 작성한다.

    간소화된 Cα-only 모델: 각 잔기에 CA 원자만 기록.
    OpenMM 등에서 전체 원자 모델로 재구성(reconstruct)할 때의 입력으로 사용.

    Parameters
    ----------
    filepath : str or Path
    ca_coords : np.ndarray of shape (N, 3)
    residue_names : list[str] of length N (3글자 코드)
    chain_id : str
    pdb_id : str
    b_factors : np.ndarray of shape (N,), optional
        각 잔기의 B-factor. None이면 0.0.

    Returns
    -------
    Path — 작성된 파일 경로
    """
    filepath = Path(filepath)
    filepath.parent.mkdir(parents=True, exist_ok=True)

    n = len(ca_coords)
    if len(residue_names) != n:
        raise ValueError(
            f"좌표 수({n})와 잔기 이름 수({len(residue_names)})가 불일치"
        )

    if b_factors is None:
        b_factors = np.zeros(n)

    lines = []
    lines.append(f"HEADER    UFoE GENERATED STRUCTURE          {pdb_id}")
    lines.append(f"REMARK   1 Generated by UFoE Phase 2 Pipeline")
    lines.append(f"REMARK   2 Residues: {n}")

    for i in range(n):
        atom_serial = i + 1
        resname = residue_names[i]
        resseq = i + 1
        x, y, z = ca_coords[i]
        bf = b_factors[i]

        # PDB ATOM 레코드 형식 (80 컬럼)
        # ATOM  serial name altLoc resName chainID resSeq iCode x y z occ bfact element
        line = (
            f"ATOM  {atom_serial:5d}  CA  {resname:3s} {chain_id:1s}"
            f"{resseq:4d}    "
            f"{x:8.3f}{y:8.3f}{z:8.3f}"
            f"{1.00:6.2f}{bf:6.2f}          C  "
        )
        lines.append(line)

    lines.append("TER")
    lines.append("END")

    with open(filepath, "w") as f:
        f.write("\n".join(lines) + "\n")

    return filepath


def write_pdb_from_structure(
    filepath: str | Path,
    structure: ProteinStructure,
) -> Path:
    """ProteinStructure 객체를 PDB 파일로 작성한다.

    Parameters
    ----------
    filepath : str or Path
    structure : ProteinStructure

    Returns
    -------
    Path
    """
    ca_coords = structure.ca_coords
    residue_names = [r.name for r in structure.residues]
    chain_id = structure.residues[0].chain if structure.residues else PDB_CHAIN_DEFAULT

    return write_pdb_from_coords(
        filepath=filepath,
        ca_coords=ca_coords,
        residue_names=residue_names,
        chain_id=chain_id,
        pdb_id=structure.pdb_id,
    )


def sequence_to_fasta(
    filepath: str | Path,
    sequence: str,
    seq_id: str = "ufoe_generated",
    description: str = "",
) -> Path:
    """아미노산 서열을 FASTA 형식으로 저장한다.

    ESMFold 입력용.

    Parameters
    ----------
    filepath : str or Path
    sequence : str — 1글자 아미노산 서열
    seq_id : str
    description : str

    Returns
    -------
    Path
    """
    filepath = Path(filepath)
    filepath.parent.mkdir(parents=True, exist_ok=True)

    header = f">{seq_id}"
    if description:
        header += f" {description}"

    # FASTA는 80자 줄바꿈 관례
    seq_lines = [sequence[i:i + 80] for i in range(0, len(sequence), 80)]

    with open(filepath, "w") as f:
        f.write(header + "\n")
        f.write("\n".join(seq_lines) + "\n")

    return filepath


def read_pdb_coords(filepath: str | Path) -> tuple[np.ndarray, list[str]]:
    """PDB 파일에서 Cα 좌표와 잔기 이름을 읽는다.

    Parameters
    ----------
    filepath : str or Path

    Returns
    -------
    (ca_coords, residue_names)
    """
    filepath = Path(filepath)
    coords = []
    names = []

    with open(filepath, "r") as f:
        for line in f:
            if line.startswith("ATOM") or line.startswith("HETATM"):
                atom_name = line[12:16].strip()
                if atom_name == "CA":
                    x = float(line[30:38])
                    y = float(line[38:46])
                    z = float(line[46:54])
                    resname = line[17:20].strip()
                    coords.append([x, y, z])
                    names.append(resname)

    return np.array(coords), names
